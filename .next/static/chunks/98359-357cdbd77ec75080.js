"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[98359],{98359:(e,t,r)=>{r.d(t,{Kp:()=>b,NJ:()=>w,hL:()=>g,jO:()=>m,n:()=>h,rn:()=>f,t6:()=>y});var n=r(49112),a=r(12115),i=r(31530),s=r(49509);let o=["function stake(uint256 amount) external","function unstake(uint256 amount) external","function getPoolBalance() external view returns (uint256)","function getStakerInfo(address staker) external view returns (uint256, uint256, uint256, bool)","function getPoolStats() external view returns (uint256, uint256, uint256, uint256)","function getStakingToken() external view returns (address)"],u=["function submitQuest(uint256 questId, string calldata tweetUrl) external","function verifyQuest(uint256 submissionId, bool approved, string calldata rejectionReason) external","function getQuest(uint256 questId) external view returns (tuple(uint256,string,string,string,uint256,bool,uint256,uint256,uint256,uint256,address,uint256))","function getSubmission(uint256 submissionId) external view returns (tuple(uint256,address,string,uint256,uint8,uint256,address,uint256,string))","function getActiveQuests() external view returns (uint256[])","function getPendingSubmissions() external view returns (uint256[])","function getPlayerSubmissions(address player) external view returns (uint256[])","function hasPlayerCompletedQuest(address player, uint256 questId) external view returns (bool)","function isAdmin(address account) external view returns (bool)","function getDefaultQuestId() external pure returns (uint256)"],l=["function getBadge(uint256 tokenId) external view returns (tuple(uint256,address,string,uint256,uint256,string,bool))","function getUserBadges(address user) external view returns (uint256[])","function getUserBadgeCount(address user) external view returns (uint256)","function totalSupply() external view returns (uint256)","function balanceOf(address owner) external view returns (uint256)","function tokenURI(uint256 tokenId) external view returns (string)"],c=["function approve(address spender, uint256 amount) external returns (bool)","function allowance(address owner, address spender) external view returns (uint256)","function balanceOf(address account) external view returns (uint256)","function decimals() external view returns (uint8)","function symbol() external view returns (string)"],d=()=>{let e={stakingPool:"0x4f910ef3996d7C4763EFA2fEf15265e8b918cD0b",questManager:"0x02fc1eCc6c04fdd2760E74F9343b69d9c3798aD0",nftMinter:"0x9d44cb1dbd766dd8c4ab8493dbf8cbfb9650f907",usdcToken:"0x818d24c1e6828c7e86056BFe778B13b830b49dDA"};console.log("Contract addresses loaded:",e),console.log("Environment check:",{NODE_ENV:"production",VERCEL:s.env.VERCEL,VERCEL_ENV:s.env.VERCEL_ENV});let t=Object.entries(e).filter(e=>{let[,t]=e;return!t||""===t.trim()||"undefined"===t}).map(e=>{let[t]=e;return t});return t.length>0&&(console.error("Missing contract addresses: ".concat(t.join(", "))),console.error("Please check your environment variables."),console.error("Current env vars:",{STAKING_POOL:"0x4f910ef3996d7C4763EFA2fEf15265e8b918cD0b",QUEST_MANAGER:"0x02fc1eCc6c04fdd2760E74F9343b69d9c3798aD0",NFT_MINTER:"0x9d44cb1dbd766dd8c4ab8493dbf8cbfb9650f907",USDC_TOKEN:"0x818d24c1e6828c7e86056BFe778B13b830b49dDA"}),console.error("All process.env keys with NEXT_PUBLIC:",Object.keys(s.env).filter(e=>e.startsWith("NEXT_PUBLIC")))),e};function g(){let{stakingPool:e}=d(),{contract:t}=(0,n.ku)(e||"",o),{data:s,refetch:u}=(0,n.qx)(t,"getPoolBalance"),{data:l,refetch:c}=(0,n.qx)(t,"getPoolStats"),{mutateAsync:g,isPending:f}=(0,n.t4)(t,"stake"),{mutateAsync:m,isPending:b}=(0,n.t4)(t,"unstake"),h=(0,a.useCallback)(async n=>{if(!t||!n||!e)return null;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415)),a=await e({contract:t,method:"getStakerInfo",params:[n]});if(a&&Array.isArray(a)&&a.length>=4)return{stakedAmount:a[0],stakeTimestamp:a[1],lastUpdateTime:a[2],isActive:a[3]};return{stakedAmount:BigInt(0),stakeTimestamp:BigInt(0),lastUpdateTime:BigInt(0),isActive:!1}}catch(e){return console.error("Error fetching staker info:",e),{stakedAmount:BigInt(0),stakeTimestamp:BigInt(0),lastUpdateTime:BigInt(0),isActive:!1}}},[t,e]),w=(0,a.useCallback)(async r=>{if(!t||!e)throw Error("Contract not available or not configured");try{let e=await g([r]);return i.oR.success("Tokens staked successfully!"),await Promise.all([u(),c()]),e}catch(e){throw console.error("Staking error:",e),i.oR.error((null==e?void 0:e.message)||"Failed to stake tokens"),e}},[t,g,u,c,e]),y=(0,a.useCallback)(async r=>{if(!t||!e)throw Error("Contract not available or not configured");try{let e=await m([r]);return i.oR.success("Tokens unstaked successfully!"),await Promise.all([u(),c()]),e}catch(e){throw console.error("Unstaking error:",e),i.oR.error((null==e?void 0:e.message)||"Failed to unstake tokens"),e}},[t,m,u,c,e]);return{contract:t,poolBalance:s,poolStats:l,isStaking:f,isUnstaking:b,getStakerInfo:h,stakeTokens:w,unstakeTokens:y,refetchPoolBalance:u,refetchPoolStats:c}}function f(){let{questManager:e}=d(),{contract:t}=(0,n.ku)(e||"",u),{data:s,refetch:o}=(0,n.qx)(t,"getActiveQuests"),{data:l,refetch:c}=(0,n.qx)(t,"getPendingSubmissions"),{data:g}=(0,n.qx)(t,"getDefaultQuestId"),{mutateAsync:f,isPending:m}=(0,n.t4)(t,"submitQuest"),{mutateAsync:b,isPending:h}=(0,n.t4)(t,"verifyQuest"),{mutateAsync:w,isPending:y}=(0,n.t4)(t,"toggleQuestStatus"),k=(0,a.useCallback)(async n=>{if(!t||!e)return null;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415)),a=await e({contract:t,method:"getQuest",params:[n]});if(a&&Array.isArray(a)&&a.length>=12)return{questId:a[0],title:a[1],description:a[2],requirements:a[3],rewardAmount:a[4],isActive:a[5],startTime:a[6],endTime:a[7],maxCompletions:a[8],currentCompletions:a[9],creator:a[10],createTime:a[11]};return null}catch(e){return console.error("Error fetching quest:",e),null}},[t,e]),p=(0,a.useCallback)(async n=>{if(!t||!e)return null;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415)),a=await e({contract:t,method:"getSubmission",params:[n]});if(a&&Array.isArray(a)&&a.length>=9)return{questId:a[0],player:a[1],tweetUrl:a[2],submitTime:a[3],status:a[4],verifyTime:a[5],verifiedBy:a[6],nftTokenId:a[7],rejectionReason:a[8]};return null}catch(e){return console.error("Error fetching submission:",e),null}},[t,e]),v=(0,a.useCallback)(async n=>{if(!t||!n||!e)return null;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415));return await e({contract:t,method:"getPlayerSubmissions",params:[n]})}catch(e){return console.error("Error fetching player submissions:",e),[]}},[t,e]),E=(0,a.useCallback)(async(n,a)=>{if(!t||!n||!e)return!1;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415));return await e({contract:t,method:"hasPlayerCompletedQuest",params:[n,a]})}catch(e){return console.error("Error checking quest completion:",e),!1}},[t,e]),C=(0,a.useCallback)(async n=>{if(!t||!n||!e)return!1;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415));return await e({contract:t,method:"isAdmin",params:[n]})}catch(e){return console.error("Error checking admin status:",e),!1}},[t,e]),x=(0,a.useCallback)(async(r,n)=>{if(!t||!e)throw Error("Contract not available or not configured");try{let e=await f([r,n]);return i.oR.success("Quest submitted successfully! Waiting for verification..."),await o(),e}catch(e){throw console.error("Submit quest error:",e),i.oR.error((null==e?void 0:e.message)||"Failed to submit quest"),e}},[t,f,o,e]),A=(0,a.useCallback)(async function(r,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if(!t||!e)throw Error("Contract not available or not configured");try{let e=await b([r,n,a]);return i.oR.success("Quest ".concat(n?"approved":"rejected"," successfully!")),await c(),e}catch(e){throw console.error("Verify quest error:",e),i.oR.error((null==e?void 0:e.message)||"Failed to verify quest"),e}},[t,b,c,e]),I=(0,a.useCallback)(async r=>{if(!t||!e)throw Error("Contract not available or not configured");try{let e=await w([r]);return i.oR.success("Quest status updated successfully!"),await o(),e}catch(e){throw console.error("Toggle quest status error:",e),i.oR.error((null==e?void 0:e.message)||"Failed to toggle quest status"),e}},[t,w,o,e]);return{contract:t,activeQuests:s,pendingSubmissions:l,defaultQuestId:g,isSubmitting:m,isVerifying:h,isToggling:y,getQuest:k,getSubmission:p,getPlayerSubmissions:v,hasPlayerCompleted:E,checkIsAdmin:C,submitQuestProof:x,verifyQuestSubmission:A,toggleQuestStatus:I,refetchActiveQuests:o,refetchPendingSubmissions:c}}function m(){let{nftMinter:e}=d(),{contract:t}=(0,n.ku)(e||"",l),{data:i}=(0,n.qx)(t,"totalSupply"),s=(0,a.useCallback)(async n=>{if(!t||!n||!e)return null;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415));return await e({contract:t,method:"getUserBadges",params:[n]})}catch(e){return console.error("Error fetching user badges:",e),[]}},[t,e]),o=(0,a.useCallback)(async n=>{if(!t||!e)return null;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415)),a=await e({contract:t,method:"getBadge",params:[n]});if(a&&Array.isArray(a)&&a.length>=7)return{questId:a[0],recipient:a[1],tweetUrl:a[2],mintTime:a[3],questReward:a[4],questTitle:a[5],isValid:a[6]};return null}catch(e){return console.error("Error fetching badge:",e),null}},[t,e]),u=(0,a.useCallback)(async n=>{if(!t||!n||!e)return 0;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415)),a=await e({contract:t,method:"getUserBadgeCount",params:[n]});return Number(a)||0}catch(e){return console.error("Error fetching user badge count:",e),0}},[t,e]),c=(0,a.useCallback)(async n=>{if(!t||!e)return null;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415));return await e({contract:t,method:"tokenURI",params:[n]})||""}catch(e){return console.error("Error fetching token URI:",e),null}},[t,e]);return{contract:t,totalSupply:i,getUserBadges:s,getBadge:o,getUserBadgeCount:u,getTokenURI:c}}function b(){let{usdcToken:e}=d(),{contract:t}=(0,n.ku)(e||"",c),{data:s}=(0,n.qx)(t,"decimals"),{data:o}=(0,n.qx)(t,"symbol"),{mutateAsync:u,isPending:l}=(0,n.t4)(t,"approve"),g=(0,a.useCallback)(async n=>{if(!t||!n||!e)return null;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415));return await e({contract:t,method:"balanceOf",params:[n]})}catch(e){return console.error("Error fetching USDC balance:",e),BigInt(0)}},[t,e]),f=(0,a.useCallback)(async(n,a)=>{if(!t||!n||!a||!e)return null;try{let{readContract:e}=await r.e(47415).then(r.bind(r,47415));return await e({contract:t,method:"allowance",params:[n,a]})}catch(e){return console.error("Error fetching allowance:",e),BigInt(0)}},[t,e]),m=(0,a.useCallback)(async(r,n)=>{if(!t||!e)throw Error("Contract not available or not configured");try{let e=await u([r,n]);return i.oR.success("Approval successful!"),e}catch(e){throw console.error("Approve error:",e),i.oR.error((null==e?void 0:e.message)||"Failed to approve spending"),e}},[t,u,e]);return{contract:t,decimals:s,symbol:o,isApproving:l,getBalance:g,getAllowance:f,approveSpender:m}}function h(){let e=g(),t=f(),r=m(),n=b(),i=(0,a.useMemo)(()=>({staking:e.isStaking,unstaking:e.isUnstaking,submitting:t.isSubmitting,verifying:t.isVerifying,approving:n.isApproving}),[e.isStaking,e.isUnstaking,t.isSubmitting,t.isVerifying,n.isApproving]),s=(0,a.useMemo)(()=>Object.values(i).some(e=>e),[i]);return{stakingPool:e,questManager:t,nftMinter:r,usdcToken:n,isLoading:i,isAnyLoading:s}}function w(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:6,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2;if(!e)return"0";try{let n=BigInt(10**t),a=e/n,i=e%n;if(i===BigInt(0))return a.toString();let s=i.toString().padStart(t,"0").slice(0,r).replace(/0+$/,"");return s?"".concat(a,".").concat(s):a.toString()}catch(e){return console.error("Error formatting token amount:",e),"0"}}function y(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:6;try{let[r,n=""]=e.split("."),a=n.padEnd(t,"0").slice(0,t);return BigInt(r+a)}catch(e){return console.error("Error parsing token amount:",e),BigInt(0)}}}}]);