"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[15179],{15179:(a,e,t)=>{t.d(e,{relayEngineTransaction:()=>l});var r=t(2579),n=t(8118),s=t(26489),i=t(76016);async function o({account:a,serializableTransaction:e,transaction:t,gasless:n}){let i=(0,r.P)({address:n.relayerForwarderAddress,chain:t.chain,client:t.client}),o=await (0,s.readContract)({contract:i,method:"function getNonce(address) view returns (uint256)",params:[a.address]}),[l,u]=await (async()=>{if(!e.to)throw Error("engine transactions must have a 'to' address");if(!e.gas)throw Error("engine transactions must have a 'gas' value");if(!e.data)throw Error("engine transactions must have a 'data' value");if(n.experimentalChainlessSupport){let r={chainid:BigInt(t.chain.id),data:e.data,from:a.address,gas:e.gas,nonce:o,to:e.to,value:0n};return[await a.signTypedData({domain:{name:"GSNv2 Forwarder",verifyingContract:i.address,version:"0.0.1"},message:r,primaryType:"ForwardRequest",types:{ForwardRequest:c}}),r]}let r={data:e.data,from:a.address,gas:e.gas,nonce:o,to:e.to,value:0n};return[await a.signTypedData({domain:{chainId:t.chain.id,name:n.domainName??"GSNv2 Forwarder",verifyingContract:i.address,version:n.domainVersion??"0.0.1"},message:r,primaryType:"ForwardRequest",types:{ForwardRequest:d}}),r]})();return{message:u,messageType:"forward",signature:l}}let d=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"}],c=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"},{name:"chainid",type:"uint256"}];async function l(a){let{message:e,messageType:t,signature:r}=await o(a),s=await fetch(a.gasless.relayerUrl,{body:(0,n.stringify)({forwarderAddress:a.gasless.relayerForwarderAddress,request:e,signature:r,type:t}),headers:{"Content-Type":"application/json"},method:"POST"});if(!s.ok)throw Error(`Failed to send transaction: ${await s.text()}`);let i=await s.json();if(!i.result)throw Error(`Relay transaction failed: ${i.message}`);let d=i.result.queueId,c=Date.now()+6e4;for(;Date.now()<c;){let e=await u({options:a,queueId:d});if(e)return{chain:a.transaction.chain,client:a.transaction.client,transactionHash:e.transactionHash};await new Promise(a=>setTimeout(a,1e3))}throw Error("Failed to find relayed transaction after 60000ms")}async function u(a){let{options:e,queueId:t}=a,r=e.gasless.relayerUrl.split("/relayer/")[0],n=await fetch(`${r}/transaction/status/${t}`,{method:"GET"}),s=await n.json();if(!n.ok)return null;let o=s.result;if(!o)return null;switch(o.status){case"errored":throw Error(`Transaction errored with reason: ${o.errorMessage}`);case"cancelled":throw Error("Transaction execution cancelled.");case"mined":return await (0,i.L)({chain:e.transaction.chain,client:e.transaction.client,transactionHash:o.transactionHash});default:return null}}}}]);