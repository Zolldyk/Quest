"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[98359],{98359:(e,t,n)=>{n.d(t,{Kp:()=>f,NJ:()=>b,hL:()=>m,jO:()=>y,n:()=>g,rn:()=>p,t6:()=>h});var r=n(49112),a=n(12115),s=n(31530),i=n(49509);let o=["function stake(uint256 amount) external","function unstake(uint256 amount) external","function getPoolBalance() external view returns (uint256)","function getStakerInfo(address staker) external view returns (uint256, uint256, uint256, bool)","function getPoolStats() external view returns (uint256, uint256, uint256, uint256)","function getStakingToken() external view returns (address)"],u=[{type:"error",name:"QuestManager__InvalidAddress",inputs:[]},{type:"error",name:"QuestManager__InvalidAmount",inputs:[]},{type:"error",name:"QuestManager__QuestNotFound",inputs:[]},{type:"error",name:"QuestManager__QuestAlreadySubmitted",inputs:[]},{type:"error",name:"QuestManager__QuestNotSubmitted",inputs:[]},{type:"error",name:"QuestManager__QuestAlreadyCompleted",inputs:[]},{type:"error",name:"QuestManager__QuestAlreadyRejected",inputs:[]},{type:"error",name:"QuestManager__Unauthorized",inputs:[]},{type:"error",name:"QuestManager__EmptyTweetUrl",inputs:[]},{type:"error",name:"QuestManager__InvalidQuestId",inputs:[]},{type:"error",name:"QuestManager__InsufficientPoolBalance",inputs:[]},{type:"error",name:"QuestManager__QuestNotActive",inputs:[]},{type:"error",name:"QuestManager__SubmissionWindowClosed",inputs:[]},{type:"error",name:"QuestManager__PlayerAlreadyCompleted",inputs:[]},{type:"function",name:"submitQuest",inputs:[{name:"questId",type:"uint256"},{name:"tweetUrl",type:"string"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"verifyQuest",inputs:[{name:"submissionId",type:"uint256"},{name:"approved",type:"bool"},{name:"rejectionReason",type:"string"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"getQuest",inputs:[{name:"questId",type:"uint256"}],outputs:[{name:"",type:"tuple",components:[{name:"questId",type:"uint256"},{name:"title",type:"string"},{name:"description",type:"string"},{name:"requirements",type:"string"},{name:"rewardAmount",type:"uint256"},{name:"isActive",type:"bool"},{name:"startTime",type:"uint256"},{name:"endTime",type:"uint256"},{name:"maxCompletions",type:"uint256"},{name:"currentCompletions",type:"uint256"},{name:"creator",type:"address"},{name:"createTime",type:"uint256"}]}],stateMutability:"view"},{type:"function",name:"getSubmission",inputs:[{name:"submissionId",type:"uint256"}],outputs:[{name:"",type:"tuple",components:[{name:"questId",type:"uint256"},{name:"player",type:"address"},{name:"tweetUrl",type:"string"},{name:"submitTime",type:"uint256"},{name:"status",type:"uint8"},{name:"verifyTime",type:"uint256"},{name:"verifiedBy",type:"address"},{name:"nftTokenId",type:"uint256"},{name:"rejectionReason",type:"string"}]}],stateMutability:"view"},{type:"function",name:"getActiveQuests",inputs:[],outputs:[{name:"",type:"uint256[]"}],stateMutability:"view"},{type:"function",name:"getPendingSubmissions",inputs:[],outputs:[{name:"",type:"uint256[]"}],stateMutability:"view"},{type:"function",name:"getPlayerSubmissions",inputs:[{name:"player",type:"address"}],outputs:[{name:"",type:"uint256[]"}],stateMutability:"view"},{type:"function",name:"hasPlayerCompletedQuest",inputs:[{name:"player",type:"address"},{name:"questId",type:"uint256"}],outputs:[{name:"",type:"bool"}],stateMutability:"view"},{type:"function",name:"isAdmin",inputs:[{name:"account",type:"address"}],outputs:[{name:"",type:"bool"}],stateMutability:"view"},{type:"function",name:"getDefaultQuestId",inputs:[],outputs:[{name:"",type:"uint256"}],stateMutability:"pure"}],l=["function getBadge(uint256 tokenId) external view returns (tuple(uint256,address,string,uint256,uint256,string,bool))","function getUserBadges(address user) external view returns (uint256[])","function getUserBadgeCount(address user) external view returns (uint256)","function totalSupply() external view returns (uint256)","function balanceOf(address owner) external view returns (uint256)","function tokenURI(uint256 tokenId) external view returns (string)"],c=["function approve(address spender, uint256 amount) external returns (bool)","function allowance(address owner, address spender) external view returns (uint256)","function balanceOf(address account) external view returns (uint256)","function decimals() external view returns (uint8)","function symbol() external view returns (string)"],d=()=>{let e={stakingPool:"0x4f910ef3996d7C4763EFA2fEf15265e8b918cD0b".trim(),questManager:"0x02fc1eCc6c04fdd2760E74F9343b69d9c3798aD0".trim(),nftMinter:"0x9d44cb1dbd766dd8c4ab8493dbf8cbfb9650f907".trim(),usdcToken:"0x818d24c1e6828c7e86056BFe778B13b830b49dDA".trim()};console.log("Contract addresses loaded:",e),console.log("Environment check:",{NODE_ENV:"production",VERCEL:i.env.VERCEL,VERCEL_ENV:i.env.VERCEL_ENV});let t=Object.entries(e).filter(e=>{let[,t]=e;return!t||""===t.trim()||"undefined"===t}).map(e=>{let[t]=e;return t});return t.length>0&&(console.error("Missing contract addresses: ".concat(t.join(", "))),console.error("Please check your environment variables."),console.error("Current env vars:",{STAKING_POOL:"0x4f910ef3996d7C4763EFA2fEf15265e8b918cD0b",QUEST_MANAGER:"0x02fc1eCc6c04fdd2760E74F9343b69d9c3798aD0",NFT_MINTER:"0x9d44cb1dbd766dd8c4ab8493dbf8cbfb9650f907",USDC_TOKEN:"0x818d24c1e6828c7e86056BFe778B13b830b49dDA"}),console.error("All process.env keys with NEXT_PUBLIC:",Object.keys(i.env).filter(e=>e.startsWith("NEXT_PUBLIC")))),e};function m(){let{stakingPool:e}=d(),{contract:t}=(0,r.ku)(e||"",o),{data:i,refetch:u}=(0,r.qx)(t,"getPoolBalance"),{data:l,refetch:c}=(0,r.qx)(t,"getPoolStats"),{mutateAsync:m,isPending:p}=(0,r.t4)(t,"stake"),{mutateAsync:y,isPending:f}=(0,r.t4)(t,"unstake"),g=(0,a.useCallback)(async r=>{if(!t||!r||!e)return null;try{let{readContract:e}=await n.e(47415).then(n.bind(n,47415)),a=await e({contract:t,method:"getStakerInfo",params:[r]});if(a&&Array.isArray(a)&&a.length>=4)return{stakedAmount:a[0],stakeTimestamp:a[1],lastUpdateTime:a[2],isActive:a[3]};return{stakedAmount:BigInt(0),stakeTimestamp:BigInt(0),lastUpdateTime:BigInt(0),isActive:!1}}catch(e){return console.error("Error fetching staker info:",e),{stakedAmount:BigInt(0),stakeTimestamp:BigInt(0),lastUpdateTime:BigInt(0),isActive:!1}}},[t,e]),b=(0,a.useCallback)(async n=>{if(!t||!e)throw Error("Contract not available or not configured");try{let e=await m([n]);return s.oR.success("Tokens staked successfully!"),await Promise.all([u(),c()]),e}catch(e){throw console.error("Staking error:",e),s.oR.error((null==e?void 0:e.message)||"Failed to stake tokens"),e}},[t,m,u,c,e]),h=(0,a.useCallback)(async n=>{if(!t||!e)throw Error("Contract not available or not configured");try{let e=await y([n]);return s.oR.success("Tokens unstaked successfully!"),await Promise.all([u(),c()]),e}catch(e){throw console.error("Unstaking error:",e),s.oR.error((null==e?void 0:e.message)||"Failed to unstake tokens"),e}},[t,y,u,c,e]);return{contract:t,poolBalance:i,poolStats:l,isStaking:p,isUnstaking:f,getStakerInfo:g,stakeTokens:b,unstakeTokens:h,refetchPoolBalance:u,refetchPoolStats:c}}function p(){let e=d(),{questManager:t}=e;console.log("useQuestManager hook initializing:",{questManager:t,questManagerAddress:t||"EMPTY",allAddresses:e,envVarsDirectly:{QUEST_MANAGER:"0x02fc1eCc6c04fdd2760E74F9343b69d9c3798aD0",STAKING_POOL:"0x4f910ef3996d7C4763EFA2fEf15265e8b918cD0b",NFT_MINTER:"0x9d44cb1dbd766dd8c4ab8493dbf8cbfb9650f907",USDC_TOKEN:"0x818d24c1e6828c7e86056BFe778B13b830b49dDA",THIRDWEB_CLIENT_ID:"0721f1503db0f0f8f7e4f1231d2e9ddf"}});let{contract:i}=(0,r.ku)(t||"",u);console.log("useQuestManager contract result:",{contract:!!i,contractAddress:null==i?void 0:i.address,questManagerParam:t,contractObject:i});let{data:o,refetch:l}=(0,r.qx)(i,"getActiveQuests"),{data:c,refetch:m}=(0,r.qx)(i,"getPendingSubmissions"),{data:p}=(0,r.qx)(i,"getDefaultQuestId"),{mutateAsync:y,isPending:f}=(0,r.t4)(i,"submitQuest"),{mutateAsync:g,isPending:b}=(0,r.t4)(i,"verifyQuest"),{mutateAsync:h,isPending:v}=(0,r.t4)(i,"toggleQuestStatus"),w=(0,a.useCallback)(async e=>{if(!i||!t)return null;try{let{readContract:t}=await n.e(47415).then(n.bind(n,47415)),r=await t({contract:i,method:"getQuest",params:[e]});if(r&&Array.isArray(r)&&r.length>=12)return{questId:r[0],title:r[1],description:r[2],requirements:r[3],rewardAmount:r[4],isActive:r[5],startTime:r[6],endTime:r[7],maxCompletions:r[8],currentCompletions:r[9],creator:r[10],createTime:r[11]};return null}catch(e){return console.error("Error fetching quest:",e),null}},[i,t]),E=(0,a.useCallback)(async e=>{if(!i||!t)return null;try{let{readContract:t}=await n.e(47415).then(n.bind(n,47415)),r=await t({contract:i,method:"getSubmission",params:[e]});if(r&&Array.isArray(r)&&r.length>=9)return{questId:r[0],player:r[1],tweetUrl:r[2],submitTime:r[3],status:r[4],verifyTime:r[5],verifiedBy:r[6],nftTokenId:r[7],rejectionReason:r[8]};return null}catch(e){return console.error("Error fetching submission:",e),null}},[i,t]),k=(0,a.useCallback)(async e=>{if(!i||!e||!t)return null;try{let{readContract:t}=await n.e(47415).then(n.bind(n,47415));return await t({contract:i,method:"getPlayerSubmissions",params:[e]})}catch(e){return console.error("Error fetching player submissions:",e),[]}},[i,t]),C=(0,a.useCallback)(async(e,r)=>{if(!i||!e||!t)return!1;try{let{readContract:t}=await n.e(47415).then(n.bind(n,47415));return await t({contract:i,method:"hasPlayerCompletedQuest",params:[e,r]})}catch(e){return console.error("Error checking quest completion:",e),!1}},[i,t]),A=(0,a.useCallback)(async e=>{if(!i||!e||!t)return!1;try{let{readContract:t}=await n.e(47415).then(n.bind(n,47415));return await t({contract:i,method:"isAdmin",params:[e]})}catch(e){return console.error("Error checking admin status:",e),!1}},[i,t]),T=(0,a.useCallback)(async(e,n)=>{if(console.log("submitQuestProof called with:",{questId:e,tweetUrl:n,contract:!!i,contractDetails:{exists:!!i,address:null==i?void 0:i.address,type:typeof i,keys:i?Object.keys(i):"NO_CONTRACT"},questManager:t,questManagerType:typeof t,questManagerValue:t,submitQuest:typeof y,submitQuestExists:!!y}),!i)throw console.error("CONTRACT IS NULL/UNDEFINED:",{contract:i,contractType:typeof i,questManager:t,questManagerType:typeof t,allEnvVars:{QUEST_MANAGER:"0x02fc1eCc6c04fdd2760E74F9343b69d9c3798aD0",STAKING_POOL:"0x4f910ef3996d7C4763EFA2fEf15265e8b918cD0b",NFT_MINTER:"0x9d44cb1dbd766dd8c4ab8493dbf8cbfb9650f907",USDC_TOKEN:"0x818d24c1e6828c7e86056BFe778B13b830b49dDA",THIRDWEB_CLIENT_ID:"0721f1503db0f0f8f7e4f1231d2e9ddf"}}),Error("Contract not available or not configured - contract is null");if(!t)throw console.error("QUEST_MANAGER ADDRESS IS EMPTY:",{questManager:t,questManagerType:typeof t,contractExists:!!i,contractAddress:null==i?void 0:i.address,envVar:"0x02fc1eCc6c04fdd2760E74F9343b69d9c3798aD0"}),Error("Contract not available or not configured - questManager address is empty");console.log("SUCCESS: Contract and questManager are both available!",{contractAddress:i.address,questManagerAddress:t,submitQuestFunction:typeof y}),alert("SUCCESS: Contract connection established! Proceeding with quest submission...");try{console.log("About to call submitQuest with params:",[e,n]);let t=await y([e,n]);return console.log("submitQuest transaction result:",t),s.oR.success("Quest submitted successfully! Waiting for verification..."),await l(),t}catch(e){throw console.error("Submit quest error:",e),console.error("Submit quest error details:",{message:null==e?void 0:e.message,cause:null==e?void 0:e.cause,stack:null==e?void 0:e.stack,reason:null==e?void 0:e.reason,code:null==e?void 0:e.code}),s.oR.error((null==e?void 0:e.message)||"Failed to submit quest"),e}},[i,y,l,t]),I=(0,a.useCallback)(async function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if(!i||!t)throw Error("Contract not available or not configured");try{let t=await g([e,n,r]);return s.oR.success("Quest ".concat(n?"approved":"rejected"," successfully!")),await m(),t}catch(e){throw console.error("Verify quest error:",e),s.oR.error((null==e?void 0:e.message)||"Failed to verify quest"),e}},[i,g,m,t]),_=(0,a.useCallback)(async e=>{if(!i||!t)throw Error("Contract not available or not configured");try{let t=await h([e]);return s.oR.success("Quest status updated successfully!"),await l(),t}catch(e){throw console.error("Toggle quest status error:",e),s.oR.error((null==e?void 0:e.message)||"Failed to toggle quest status"),e}},[i,h,l,t]);return{contract:i,activeQuests:o,pendingSubmissions:c,defaultQuestId:p,isSubmitting:f,isVerifying:b,isToggling:v,getQuest:w,getSubmission:E,getPlayerSubmissions:k,hasPlayerCompleted:C,checkIsAdmin:A,submitQuestProof:T,verifyQuestSubmission:I,toggleQuestStatus:_,refetchActiveQuests:l,refetchPendingSubmissions:m}}function y(){let{nftMinter:e}=d(),{contract:t}=(0,r.ku)(e||"",l),{data:s}=(0,r.qx)(t,"totalSupply"),i=(0,a.useCallback)(async r=>{if(!t||!r||!e)return null;try{let{readContract:e}=await n.e(47415).then(n.bind(n,47415));return await e({contract:t,method:"getUserBadges",params:[r]})}catch(e){return console.error("Error fetching user badges:",e),[]}},[t,e]),o=(0,a.useCallback)(async r=>{if(!t||!e)return null;try{let{readContract:e}=await n.e(47415).then(n.bind(n,47415)),a=await e({contract:t,method:"getBadge",params:[r]});if(a&&Array.isArray(a)&&a.length>=7)return{questId:a[0],recipient:a[1],tweetUrl:a[2],mintTime:a[3],questReward:a[4],questTitle:a[5],isValid:a[6]};return null}catch(e){return console.error("Error fetching badge:",e),null}},[t,e]),u=(0,a.useCallback)(async r=>{if(!t||!r||!e)return 0;try{let{readContract:e}=await n.e(47415).then(n.bind(n,47415)),a=await e({contract:t,method:"getUserBadgeCount",params:[r]});return Number(a)||0}catch(e){return console.error("Error fetching user badge count:",e),0}},[t,e]),c=(0,a.useCallback)(async r=>{if(!t||!e)return null;try{let{readContract:e}=await n.e(47415).then(n.bind(n,47415));return await e({contract:t,method:"tokenURI",params:[r]})||""}catch(e){return console.error("Error fetching token URI:",e),null}},[t,e]);return{contract:t,totalSupply:s,getUserBadges:i,getBadge:o,getUserBadgeCount:u,getTokenURI:c}}function f(){let{usdcToken:e}=d(),{contract:t}=(0,r.ku)(e||"",c),{data:i}=(0,r.qx)(t,"decimals"),{data:o}=(0,r.qx)(t,"symbol"),{mutateAsync:u,isPending:l}=(0,r.t4)(t,"approve"),m=(0,a.useCallback)(async r=>{if(!t||!r||!e)return null;try{let{readContract:e}=await n.e(47415).then(n.bind(n,47415));return await e({contract:t,method:"balanceOf",params:[r]})}catch(e){return console.error("Error fetching USDC balance:",e),BigInt(0)}},[t,e]),p=(0,a.useCallback)(async(r,a)=>{if(!t||!r||!a||!e)return null;try{let{readContract:e}=await n.e(47415).then(n.bind(n,47415));return await e({contract:t,method:"allowance",params:[r,a]})}catch(e){return console.error("Error fetching allowance:",e),BigInt(0)}},[t,e]),y=(0,a.useCallback)(async(n,r)=>{if(!t||!e)throw Error("Contract not available or not configured");try{let e=await u([n,r]);return s.oR.success("Approval successful!"),e}catch(e){throw console.error("Approve error:",e),s.oR.error((null==e?void 0:e.message)||"Failed to approve spending"),e}},[t,u,e]);return{contract:t,decimals:i,symbol:o,isApproving:l,getBalance:m,getAllowance:p,approveSpender:y}}function g(){let e=m(),t=p(),n=y(),r=f(),s=(0,a.useMemo)(()=>({staking:e.isStaking,unstaking:e.isUnstaking,submitting:t.isSubmitting,verifying:t.isVerifying,approving:r.isApproving}),[e.isStaking,e.isUnstaking,t.isSubmitting,t.isVerifying,r.isApproving]),i=(0,a.useMemo)(()=>Object.values(s).some(e=>e),[s]);return{stakingPool:e,questManager:t,nftMinter:n,usdcToken:r,isLoading:s,isAnyLoading:i}}function b(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:6,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2;if(!e)return"0";try{let r=BigInt(10**t),a=e/r,s=e%r;if(s===BigInt(0))return a.toString();let i=s.toString().padStart(t,"0").slice(0,n).replace(/0+$/,"");return i?"".concat(a,".").concat(i):a.toString()}catch(e){return console.error("Error formatting token amount:",e),"0"}}function h(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:6;try{let[n,r=""]=e.split("."),a=r.padEnd(t,"0").slice(0,t);return BigInt(n+a)}catch(e){return console.error("Error parsing token amount:",e),BigInt(0)}}}}]);